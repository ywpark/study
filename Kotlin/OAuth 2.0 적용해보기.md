# OAuth 2.0 Ï†ÅÏö©Ìï¥Î≥¥Í∏∞

---

> üí°ÏÑúÎπÑÏä§ÏóêÏÑú ÏûêÏ≤¥ ÌöåÏõêÍ∞ÄÏûÖÏùÑ Ïú†ÎèÑÌïòÏó¨ ÌöåÏõêÏùÑ Í¥ÄÎ¶¨ÌïòÎäî Í≤ÉÎèÑ Ï¢ãÏßÄÎßå Ï¢Ä Îçî ÏâΩÍ≤å Ïö∞Î¶¨ ÏÑúÎπÑÏä§Î•º Ïù¥Ïö©Ìï† Ïàò ÏûàÎèÑÎ°ù Ïù¥ÎØ∏ 
> Îã§Î•∏ ÌîåÎû´ÌèºÏùÑ ÏÇ¨Ïö©ÌïòÍ≥† ÏûàÎäî ÏÇ¨Ïö©Ïûê Îç∞Ïù¥ÌÑ∞Ïóê Ï†ëÍ∑ºÌïòÍ∏∞ ÏúÑÌïòÏó¨ Ïù∏Ï¶ù Î∞è Ïù∏Í∞ÄÎ•º Îã¥ÎãπÌïòÍ≥† ÏûàÎäî ÌëúÏ§Ä ÌîÑÎ°úÌÜ†ÏΩúÏù∏ 
> OAuth Î•º ÌôúÏö©Ìï¥Î≥¥Í≥†Ïûê Ìï®


# Ï†ïÏùò

---

- Open Authorization
- Ïù∏ÌÑ∞ÎÑ∑ ÏÇ¨Ïö©ÏûêÎì§Ïù¥ ÎπÑÎ∞ÄÎ≤àÌò∏Î•º Ï†úÍ≥µÌïòÏßÄ ÏïäÍ≥† Îã§Î•∏ ÏõπÏÇ¨Ïù¥Ìä∏ ÏÉÅÏùò ÏûêÏã†Îì§Ïùò Ï†ïÎ≥¥Ïóê ÎåÄÌï¥ ÏõπÏÇ¨Ïù¥Ìä∏ÎÇò Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖòÏùò Ï†ëÍ∑º Í∂åÌïúÏùÑ Î∂ÄÏó¨Ìï† Ïàò ÏûàÎäî Í≥µÌÜµÏ†ÅÏù∏ ÏàòÎã®ÏúºÎ°úÏÑú ÏÇ¨Ïö©ÎêòÎäî Ï†ëÍ∑º ÏúÑÏûÑÏùÑ ÏúÑÌïú Í∞úÎ∞©Ìòï ÌëúÏ§Ä

# Íµ¨ÏÑ±ÏöîÏÜå

---


> üí° `Authorization Server` , `Resource Server` Í∞Ä [Î¨∏ÏÑú](https://datatracker.ietf.org/doc/html/rfc6749#section-1.2) ÏÉÅÏóêÎäî Î≥ÑÍ∞úÎ°ú Î∂ÑÎ¶¨ÎêòÏñ¥ ÏûàÏßÄÎßå
> Í∞úÎ∞úÏûêÏùò ÏÑ†ÌÉùÏóê Îî∞ÎùºÏÑú ÌïòÎÇòÏùò ÏÑúÎ≤ÑÎ°ú Íµ¨ÏÑ±Ìï† Ïàò ÏûàÎã§.

- `Resource Owner`
    - Î¶¨ÏÜåÏä§ ÏÜåÏú†Ïûê ÎòêÎäî ÏÇ¨Ïö©Ïûê
    - Ïö∞Î¶¨Ïùò ÏÑúÎπÑÏä§Î•º Ïù¥Ïö©ÌïòÎ©¥ÏÑú, Îã§Î•∏ ÌîåÎû´Ìèº( Íµ¨Í∏Ä, ÎÑ§Ïù¥Î≤Ñ, Ïπ¥Ïπ¥Ïò§Îì±) ÏùÑ Ïù¥Ïö©ÌïòÍ≥† ÏûàÎäî ÏÇ¨Ïö©Ïûê
- `Client`
    - Î≥¥Ìò∏Îêú ÏûêÏõêÏùÑ ÏÇ¨Ïö©ÌïòÎ†§Í≥† Ï†ëÍ∑º ÏöîÏ≤≠ÏùÑ ÌïòÎäî Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖò
    - Resource ServerÏùò ÏûêÏõêÏùÑ Ïù¥Ïö©ÌïòÍ≥†Ïûê ÌïòÎäî ÏÑúÎπÑÏä§, ÏùºÎ∞òÏ†ÅÏúºÎ°ú Ïö∞Î¶¨Í∞Ä Í∞úÎ∞úÌïòÎ†§Îäî ÏÑúÎπÑÏä§
- `Authorization Server`
    - Resource OwnerÎ•º Ïù∏Ï¶ùÌïòÍ≥†, ClientÏóêÍ≤å Ïï°ÏÑ∏Ïä§ ÌÜ†ÌÅ∞ÏùÑ Î∞úÍ∏âÌï¥Ï£ºÎäî ÏÑúÎ≤Ñ
    - Ïù∏Ï¶ù/Ïù∏Í∞ÄÎ•º ÏàòÌñâÌïòÎäî ÏÑúÎ≤ÑÎ°ú ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Ïùò Ï†ëÍ∑º ÏûêÍ≤©ÏùÑ ÌôïÏù∏ÌïòÍ≥† Access TokenÏùÑ Î∞úÍ∏âÌïòÏó¨ Í∂åÌïúÏùÑ Î∂ÄÏó¨ÌïòÎäî Ïó≠Ìï†
- `Resource Server`
    - ÏÇ¨Ïö©ÏûêÏùò Î≥¥Ìò∏Îêú ÏûêÏõêÏùÑ Ìò∏Ïä§ÌåÖÌïòÎäî ÏÑúÎ≤Ñ
    - Íµ¨Í∏Ä, ÎÑ§Ïù¥Î≤Ñ, Ïπ¥Ïπ¥Ïò§ÏôÄ Í∞ôÏù¥ ÏÇ¨Ïö©ÏûêÏùò Î¶¨ÏÜåÏä§Î•º Í∞ÄÏßÄÍ≥† ÏûàÎäî ÏÑúÎ≤Ñ
- `OAUTH FLOW`
    
    ![1.png](/assets/kotlin/1.png)
    
    > Ï∞∏Í≥†) [https://guide.ncloud-docs.com/docs/b2bpls-oauth2](https://guide.ncloud-docs.com/docs/b2bpls-oauth2)
    > 

# Í∞úÎ∞ú ÌôòÍ≤Ω

---

- Spring Framework boot 3.4.1
- Spring Security 6.4.2
- Kotlin

# 1. WITHOUT SPRING SECURITY

---

- application.yml
    
    ```yaml
    oauth2:
      naver:
        authorize-url: https://nid.naver.com/oauth2.0/authorize
        client-id: #Î∞úÍ∏âÎ∞õÏùÄ client id#
        client-secret: #Î∞úÍ∏âÎ∞õÏùÄ secret#
        response-type: code
        redirect-uri: https://local.exam.com:8443/login/oauth/naver
        token-url: https://nid.naver.com/oauth2.0/token
        user-info-url: https://openapi.naver.com/v1/nid/me
    ```
    
- login.html
    
    ```html
    
    // ÎÑ§Ïù¥Î≤Ñ Î°úÍ∑∏Ïù∏ Î≤ÑÌäº Click Ìï®Ïàò
    function signInByNAVER() {
    
        window.open("https://local.exam.com:8443/login/oauth/naver/authorize", "oauthPopup", "menubar=no, toolbar=no");
        window.addEventListener("message", (evt) => {
    
          console.log('evt.origin = ', evt.origin);
          console.log('window.location.origin = ', window.location.origin);
          console.log('message = ', evt.data);
    
          getAccessToken(evt.data);
        });
    
      }
    
    function getAccessToken(code) {
    
      fetch("https://local.exam.com:8443/login/oauth/naver/token?code=" + code, {
        method: 'GET'
      })
              .then(res => {
                return res.json();
              })
              .then(data => {
                console.log("json data = ", data);
                getOAuthUserInfo(data.accessToken, data.tokenType);
              });
    }
    
    function getOAuthUserInfo(accessToken, tokenType) {
    
      fetch("https://local.exam.com:8443/login/oauth/naver/info/me?token=" + accessToken + "&type=" + tokenType, {
        method: "GET"
      })
              .then(res => {
                return res.json();
              })
              .then(data => {
                console.log("naver me info = ", data);
              })
    }
    ```
    
- naver.html
    
    ```html
    <!DOCTYPE html>
    <html lang="en">
    <script>
    
      const oauth_code = '[[${code}]]';
      window.opener.postMessage(oauth_code, window.location.origin);
      window.close();
    
    </script>
    </html>
    ```
    
- OAuthController.kt
    
    ```kotlin
    package com.ywpark.exam.api.shared.controller
    
    import com.ywpark.exam.api.shared.model.TokenResult
    import com.ywpark.exam.api.shared.model.UserInfo
    import com.ywpark.exam.api.shared.service.OAuthNaverService
    import io.github.oshai.kotlinlogging.KotlinLogging
    import jakarta.servlet.http.Cookie
    import jakarta.servlet.http.HttpServletRequest
    import jakarta.servlet.http.HttpServletResponse
    import org.springframework.stereotype.Controller
    import org.springframework.ui.Model
    import org.springframework.web.bind.annotation.CookieValue
    import org.springframework.web.bind.annotation.GetMapping
    import org.springframework.web.bind.annotation.PathVariable
    import org.springframework.web.bind.annotation.RequestMapping
    import org.springframework.web.bind.annotation.RequestParam
    import org.springframework.web.bind.annotation.ResponseBody
    import java.math.BigInteger
    import java.security.SecureRandom
    
    @RequestMapping("/login/oauth")
    @Controller
    class OAuthController(
        private val oAuthNaverService: OAuthNaverService
    ) {
    
        companion object {
            private val logger = KotlinLogging.logger { }
        }
    
        @GetMapping("/{provider}/authorize")
        fun authorize(@PathVariable provider: String, httpServletRequest: HttpServletRequest, httpServletResponse: HttpServletResponse) {
    
            val random = SecureRandom()
            val state: String = BigInteger(130, random).toString(32)
    
            val oauthUrl: String = when(provider) {
                "naver" ->  {
                    oAuthNaverService.startOAuth(state)
                }
                else -> ""
            }
    
            if(oauthUrl.isEmpty()) {
    					// Error Î∞úÏÉù Ï≤òÎ¶¨
            }
    
            logger.info { "provider : ${provider} , OAuth URL : ${oauthUrl}" }
    
            val stateCookie: Cookie  = Cookie("oauth_state", state)
            stateCookie.isHttpOnly = true
            stateCookie.secure = true
            stateCookie.path = "/"
            httpServletResponse.addCookie(stateCookie)
    
            httpServletResponse.sendRedirect(oauthUrl)
        }
    
        @GetMapping("/{provider}/token")
        @ResponseBody
        fun token(@RequestParam(required = true) code: String): TokenResult {
    
            val random = SecureRandom()
            val state: String = BigInteger(130, random).toString(32)
    
            val response = oAuthNaverService.getAccessToken(code, state)
            logger.info { "token response = ${response}" }
    
            return TokenResult(response.access_token, response.refresh_token, response.token_type, response.expires_in)
        }
    
        @GetMapping("/{provider}/info/me")
        @ResponseBody
        fun infoMe(@RequestParam(required = true) token: String, @RequestParam(required = true) type: String): UserInfo {
            return oAuthNaverService.getMyInfo(token, type);
        }
    
        @GetMapping("/naver")
        fun naver(@RequestParam state: String, @RequestParam code: String, @CookieValue(value = "oauth_state", required = false) cookieValue: String?, model: Model): String {
    
            if(state != cookieValue) {
                // BadRequest
            }
    
            model.addAttribute("code", code);
            return "/oauth/naver";
        }
    
        @GetMapping("/sec/naver")
        fun secNaver(model: Model): String {
            model.addAttribute("code", "code");
            return "/oauth/naver";
        }
    }
    
    ```
    
- OAuthNaverService.kt
    
    ```kotlin
    
    package com.ywpark.exam.api.shared.service
    
    import com.ywpark.exam.api.shared.model.OAuthProfileApiResult
    import com.ywpark.exam.api.shared.model.OAuthTokenApiResult
    import com.ywpark.exam.api.shared.model.UserInfo
    import io.github.oshai.kotlinlogging.KotlinLogging
    import org.springframework.beans.factory.annotation.Value
    import org.springframework.http.HttpEntity
    import org.springframework.http.HttpHeaders
    import org.springframework.http.HttpMethod
    import org.springframework.stereotype.Service
    import org.springframework.web.client.RestTemplate
    import java.net.URLEncoder
    
    @Service
    class OAuthNaverService(
        private val restTemplate: RestTemplate
    ) {
    
        @Value("\${oauth2.naver.authorize-url}")
        lateinit var url: String;
    
        @Value("\${oauth2.naver.client-id}")
        lateinit var clientId: String
    
        @Value("\${oauth2.naver.client-secret}")
        lateinit var clientSecret: String
    
        @Value("\${oauth2.naver.response-type}")
        lateinit var responseType: String
    
        @Value("\${oauth2.naver.redirect-uri}")
        lateinit var redirectUri: String
    
        @Value("\${oauth2.naver.token-url}")
        lateinit var tokenUrl: String
    
        @Value("\${oauth2.naver.user-info-url}")
        lateinit var userInfoUrl: String
    
        companion object {
            private val logger = KotlinLogging.logger { }
        }
    
        fun startOAuth(state: String): String {
            val encUrl = URLEncoder.encode(redirectUri, "UTF-8")
            return "${url}?client_id=${clientId}&response_type=${responseType}&redirect_uri=${encUrl}&state=${state}"
        }
    
        fun getAccessToken(code: String, state: String): OAuthTokenApiResult {
            return restTemplate.getForObject(
                "${tokenUrl}?grant_type=authorization_code&client_id=${clientId}&client_secret=${clientSecret}&code=${code}&state=${state}",
                OAuthTokenApiResult::class.java) ?: throw RuntimeException("OAuth Token API Error")
        }
    
        fun getMyInfo(accessToken: String, tokenType: String): UserInfo {
    
            val headers = HttpHeaders().apply {
                set("Authorization", "${tokenType} ${accessToken}")
            }
    
            val entity = HttpEntity<String>(null, headers)
            val naverResult = restTemplate.exchange("${userInfoUrl}", HttpMethod.GET, entity, OAuthProfileApiResult::class.java).body
                ?: throw RuntimeException("OAuth NAVER PROFILE API Error")
    
            return UserInfo(
                id = naverResult.response.id,
                name = naverResult.response.name,
                email = naverResult.response.email,
                mobile = naverResult.response.mobile
            )
        }
    
    }
    ```
    
    > `lateinit`  : propertyÏùò Ï¥àÍ∏∞ÌôîÎ•º ÏßÄÏó∞ÏãúÌÇ§Îäî Ïó≠Ìï†, Í∞ùÏ≤¥ ÏÉùÏÑ± ÏãúÏóêÎäî Ï¥àÍ∏∞ÌôîÌïòÏßÄ ÏïäÍ≥†, ÎÇòÏ§ëÏóê Í∞íÏùÑ Ìï†ÎãπÌï† Ïàò ÏûàÎèÑÎ°ù Ìï¥Ï£ºÎäî ÌÇ§ÏõåÎìú
    
    Í∏∞Î≥∏Ï†ÅÏúºÎ°ú Kotlin ÏùÄ ÌÅ¥ÎûòÏä§ÏóêÏÑú ÌîÑÎ°úÌçºÌã∞ ÏÑ†Ïñ∏ÌïòÎ©¥ Î∞òÎìúÏãú Ï¥àÍ∏∞ÌôîÎ•º Ìï¥Ïïº Ìï®. Í∑∏Î†áÏßÄ ÏïäÏúºÎ©¥
    Ïª¥ÌååÏùº ÏóêÎü¨Í∞Ä Î∞úÏÉù ( `Property must be initialized or be abstract` )
    
    `lateinit` ÏùÑ ÏÇ¨Ïö©ÌïòÍ≥† Ïã∂ÏßÄ ÏïäÏúºÎ©¥ ÏïÑÎûòÏôÄ Í∞ôÏù¥ ÌôúÏö© Í∞ÄÎä•
    `class OAuthNaverService(@Value("\${oauth2.naver.authorize-url}") val url: String)`
    > 
- Naver Í∏∞Ï§ÄÏùò API ÏÑ§Î™Ö ( ÏûêÏÑ∏Ìïú API ÎÇ¥Ïö©ÏùÄ [Î¨∏ÏÑú](https://developers.naver.com/docs/login/api/api.md) ÏóêÏÑú ÌôïÏù∏ Í∞ÄÎä• )
    
    > OAuth2 Ïùò Í≤ΩÏö∞ ÌëúÏ§ÄÏù¥Í∏∞ ÎïåÎ¨∏Ïóê Îã§Î•∏ ÌîåÎû´Ìèº ÎòêÌïú Í±∞Ïùò ÎπÑÏä∑Ìïú ÌùêÎ¶Ñ
    > 
    
    STEP 1. OAuth2 Î°úÍ∑∏Ïù∏ Ìò∏Ï∂ú
    
    - URL : [https://nid.naver.com/oauth2.0/authorize](https://nid.naver.com/oauth2.0/authorize)
    - PARAMETER
        - `response_type` : code ( Í≥†Ï†ïÍ∞í )
        - `client_id` : Resource Server ÏóêÏÑú Î∞úÍ∏âÎ∞õÏùÄ client id
        - `redirect_uri` : Token ÏùÑ Ï†ÑÎã¨ Î∞õÏùÑ Client Ïùò URI
                                  Resource Server Ïóê Îì±Î°ùÌï† Îïå ÏûëÏÑ±Ìïú URI
                                  URL Ïù∏ÏΩîÎî©ÏùÑ Ï†ÅÏö©Ìïú Î¨∏ÏûêÏó¥
        - `state` :  CSRF Í≥µÍ≤©ÏùÑ Î∞©ÏßÄÌïòÍ∏∞ ÏúÑÌïú ÏûÑÏùòÏùò Î¨∏ÏûêÏó¥
                       Î°úÍ∑∏Ïù∏ Í≥ºÏ†ï Ï§ëÏóê ÎèôÏùºÌïú Í∞íÏùÑ Ïú†ÏßÄÌï¥Ïïº Ìï®
    - RESPONSE
        - code :  TOKEN Î∞úÍ∏âÏùÑ ÏúÑÌïú Ïù∏Í∞Ä ÏΩîÎìú
        - state : `STEP 1` ÏóêÏÑú ÏÉùÏÑ±Ìïú state Í∞í
        - error : ÏóêÎü¨ ÏΩîÎìú
        - error_description : ÏóêÎü¨ Î©îÏÑ∏ÏßÄ
    
    STEP 2. TOKEN Î∞úÍ∏â 
    
    - URL : [https://nid.naver.com/oauth2.0/token](https://nid.naver.com/oauth2.0/token)
    - PARAMETER
        - grant_type : authorization_code ( Í≥†Ï†ïÍ∞í )
                            Í∞±Ïã†, ÏÇ≠Ï†úÏóê ÎåÄÌïú Íµ¨Î∂ÑÍ∞íÎèÑ ÏûàÏßÄÎßå Ïù¥ Î∂ÄÎ∂ÑÏùÄ Ï†úÏô∏
        - client_id : Resource Server ÏóêÏÑú Î∞úÍ∏âÎ∞õÏùÄ client id
        - client_secret : Resource Server ÏóêÏÑú Î∞úÍ∏âÎ∞õÏùÄ client secret
        - code : `STEP 1` ÏóêÏÑú Î∞úÍ∏â Î∞õÏùÄ Ïù∏Í∞Ä ÏΩîÎìú
        - state : Ïã†Í∑ú ÏÉùÏÑ± or `STEP 1` ÏÉùÏÑ±Ìïú state Í∞í
    - RESPONSE
        - access_token : Ï†ëÍ∑º ÌÜ†ÌÅ∞
        - refresh_token : Í∞±Ïã† ÌÜ†ÌÅ∞
        - token_type : Bearer ( Í≥†Ï†ïÍ∞í )
        - expires_in : Ï†ëÍ∑º ÌÜ†ÌÅ∞ Ïú†Ìö®ÏãúÍ∞Ñ
        - error : ÏóêÎü¨ ÏΩîÎìú
        - error_description : ÏóêÎü¨ Î©îÏÑ∏ÏßÄ
    
    STEP 3. ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ Ï°∞Ìöå
    
    - URL : [https://openapi.naver.com/v1/nid/me](https://openapi.naver.com/v1/nid/me)
    - HEADER
        - Authorization : `STEP 2` ÏóêÏÑú Î∞õÏùÄ `${token_type} ${access_token}`
    - RESPONSE
        - resultcode : API Í≤∞Í≥º ÏΩîÎìú
        - message : API Í≤∞Í≥º Î©îÏÑ∏ÏßÄ
        - response : ÏïÑÎûòÏóê Ï†ÑÎã¨Î∞õÎäî Îç∞Ïù¥ÌÑ∞Îäî Resource Server Ïóê ÏÑ§Ï†ïÌïú Ìï≠Î™©Îì§Ïóê ÌïúÌïòÏó¨
                          Îç∞Ïù¥ÌÑ∞ Î∞õÏùÑ Ïàò ÏûàÏùå
            - id : ÎÑ§Ïù¥Î≤Ñ ÏïÑÏù¥ÎîîÍ∞Ä ÏïÑÎãå Î≥ÑÎèÑÏùò Ïú†ÎãàÌÅ¨Ìïú ÏïÑÏù¥Îîî
            - nickname : ÏÇ¨Ïö©Ïûê Î≥ÑÎ™Ö
            - name : ÏÇ¨Ïö©Ïûê Ïù¥Î¶Ñ
            - email : ÏÇ¨Ïö©Ïûê Î©îÏùºÏ£ºÏÜå
            - gender : ÏÑ±Î≥Ñ
            - age : Ïó∞Î†πÎåÄ
            - birthday : ÏÉùÏùº
            - profile_image : ÌîÑÎ°úÌïÑ ÏÇ¨ÏßÑ URL
            - birthyear : Ï∂úÏÉù Ïó∞ÎèÑ
            - mobile : Ìú¥ÎåÄÏ†ÑÌôî Î≤àÌò∏

# 2. USING SPRING SECURITY

---

- build.gradle.kts
    
    ```groovy
    dependencies {
    	implementation("org.springframework.boot:spring-boot-starter-security")
    	implementation("org.springframework.boot:spring-boot-starter-oauth2-client")
    }
    ```
    
- application.yml
    
    ```yaml
    spring:
      security:
        oauth2:
          client:
            provider:
              naver:
                authorization-uri: 'https://nid.naver.com/oauth2.0/authorize'
                token-uri: 'https://nid.naver.com/oauth2.0/token'
                user-info-uri: 'https://openapi.naver.com/v1/nid/me'
                user-name-attribute: response
            registration:
              naver:
                client-id: #Î∞úÍ∏âÎ∞õÏùÄ client id#
                client-secret: #Î∞úÍ∏âÎ∞õÏùÄ secret#
                client-authentication-method: client_secret_post
                redirect-uri: 'https://local.exam.com:8443/login/oauth2/code/naver'
                authorization-grant-type: authorization_code
                client-name: naver
                scope:
                  - profile
    ```
    
- SecurityConfig.kt
    
    ```kotlin
    package com.ywpark.exam.api.shared.config
    
    import com.ywpark.exam.api.shared.security.CustomAuthenticationFailureHandler
    import com.ywpark.exam.api.shared.security.CustomAuthenticationSuccessHandler
    import com.ywpark.exam.api.shared.security.oauth2.OAuth2SuccessHandler
    import com.ywpark.exam.api.shared.security.oauth2.OAuthFailureHandler
    import com.ywpark.exam.api.shared.security.oauth2.OAuth2UserService
    import org.springframework.context.annotation.Bean
    import org.springframework.context.annotation.Configuration
    import org.springframework.http.HttpMethod
    import org.springframework.security.config.annotation.web.builders.HttpSecurity
    import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity
    import org.springframework.security.config.http.SessionCreationPolicy
    import org.springframework.security.web.SecurityFilterChain
    
    @Configuration
    @EnableWebSecurity
    class OAuthSecurityConfig(
        private val oAuth2UserService: OAuth2UserService
    ) {
    
        @Bean
        fun configure(http: HttpSecurity): SecurityFilterChain {
    
            http
                .securityMatcher("/views/**", "/login", "/logout", "/oauth2/**", "/login/oauth2/**")
                .csrf { it.disable() }
                .authorizeHttpRequests {
                    it
                        .requestMatchers("/views/user-login", "/views/user-signup", "/oauth2/**", "/login/oauth2/**").permitAll()
                        .requestMatchers("/views/admin").hasAuthority("ADMIN") // hasRole("ADMIN") ÏùÄ ROLE_ Ïù¥ Î∂ôÏñ¥Ïïº Ìï®
                        .anyRequest().authenticated()
                }
                .sessionManagement {
                    it
                        .sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED)
                }
                .formLogin {
                    it
                        .loginPage("/views/user-login")
                        .loginProcessingUrl("/login")
                        .successHandler(CustomAuthenticationSuccessHandler())
                        .failureHandler(CustomAuthenticationFailureHandler())
                }
                .oauth2Login {
                    it
                        .loginPage("/views/user-login")
                        .userInfoEndpoint { ue -> ue.userService(oAuth2UserService) }
                        .successHandler(OAuth2SuccessHandler())
                        .failureHandler(OAuthFailureHandler())
                }
    
            return http.build()
        }
    }
    ```
    
    - `formLogin` :  ÏÑúÎπÑÏä§Ïóê ÏßÅÏ†ë ÌöåÏõêÍ∞ÄÏûÖ ÌïòÏó¨ Î°úÍ∑∏Ïù∏ÎèÑ Ìï† Ïàò ÏûàÍ∏∞ ÎïåÎ¨∏Ïóê Ï†ÅÏö©
    - `oauth2Login`  :  OAuth2 Ïó∞ÎèôÏùÑ ÏúÑÌïòÏó¨ Ï†ïÏùò
        - `loginPage` : ÏÜåÏÖúÎ°úÍ∑∏Ïù∏ÏùÑ Ìï† Ïàò ÏûàÎäî Î°úÍ∑∏Ïù∏ÌéòÏù¥ÏßÄ URL Ï†ïÏùò
        - `userInfoEndpoint` : Î°úÍ∑∏Ïù∏Ïù¥ ÏÑ±Í≥µ Ìïú Îí§Ïóê ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥Î•º Í∞ÄÏ†∏Ïò§Îäî ÏÑúÎπÑÏä§ Îì±Î°ù
        - `successHandler` : OAuth2User Í∞Ä Ï†ïÏÉÅÏ†ÅÏúºÎ°ú ÏÉùÏÑ±Îêú Îí§Ïóê ÌõÑÏ≤òÎ¶¨ ÌïòÎäî Handler
        - `failureHandler` : OAuth2User Î•º ÏÉùÏÑ±ÌïòÎäî ÎèÑÏ§ë Î¨∏Ï†úÍ∞Ä Î∞úÏÉùÌïòÎäî Í≤ΩÏö∞Ïóê ÌõÑÏ≤òÎ¶¨ 
                                    ÌïòÎäî Handler
- OAuth2UserService.kt
    
    ```kotlin
    package com.ywpark.exam.api.shared.security.oauth2
    
    import com.ywpark.exam.api.command.domain.user.enums.LoginMethod
    import com.ywpark.exam.api.command.domain.user.service.UserDomainService
    import com.ywpark.exam.api.query.service.UserQueryService
    import com.ywpark.exam.api.shared.security.LoginUser
    import io.github.oshai.kotlinlogging.KotlinLogging
    import org.springframework.security.core.authority.SimpleGrantedAuthority
    import org.springframework.security.oauth2.client.userinfo.DefaultOAuth2UserService
    import org.springframework.security.oauth2.client.userinfo.OAuth2UserRequest
    import org.springframework.security.oauth2.core.user.OAuth2User
    import org.springframework.stereotype.Service
    
    @Service
    class OAuth2UserService(
        private val userDomainService: UserDomainService,
        private val userQueryService: UserQueryService
    ) : DefaultOAuth2UserService() {
    
        companion object {
            private val logger = KotlinLogging.logger {}
        }
    
        override fun loadUser(userRequest: OAuth2UserRequest?): OAuth2User {
    
            val accessToken:String = userRequest?.accessToken?.tokenValue ?: ""
            val tokenType:String = userRequest?.accessToken?.tokenType?.value ?: ""
            val expiresIn:Long = userRequest?.accessToken?.expiresAt?.toEpochMilli() ?: 0L
    
            /**
             *
             * super.loadUser(userRequest) Ìò∏Ï∂ú Ïãú ÏïÑÎûòÏôÄ Í∞ôÏùÄ ÏóêÎü¨ Î∞úÏÉù
             * Attribute value for 'id' cannot be null
             *
             * yml ÌååÏùºÏóêÏÑú Ìï¥Îãπ property Í∞íÏù¥ id Î°ú ÎêòÏñ¥ ÏûàÏñ¥ÏÑú Î∞úÏÉù Îêú Î¨∏Ï†ú ( ÏïÑÎûòÏôÄ Í∞ôÏù¥ response Î°ú Î∞îÍøà )
             *  user-name-attribute: response
             *
             *
             */
            val user:OAuth2User  = super.loadUser(userRequest)
    
            var resultCode: String = user.attributes["resultcode"] as String
            var message: String = user.attributes["message"] as String
            if(resultCode != "00") {
                logger.error { "OAuth2 User Info Error: [$resultCode] $message" }
                throw IllegalArgumentException("OAuth2 ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ Ï°∞Ìöå Ïã§Ìå®")
            }
    
            val userInfo:Map<String, String> = user.attributes["response"] as Map<String, String>
            logger.info { "OAuth2 User Info: $userInfo" }
    
            // ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ Ï°∞Ìöå
            val loginUser: LoginUser? = userQueryService.getUserByLoginId(userInfo["email"] as String)?.let {
    
                /**
                 * ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥Í∞Ä ÏûàÏúºÎ©¥ token Ï†ïÎ≥¥Îßå Í∞±Ïã†ÌïúÎã§.
                 */
                userDomainService.updateOAuthToken(
                    it.idx,
                    accessToken,
                    tokenType,
                    expiresIn,
                    resultCode,
                    message)
    
                // ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ return
                LoginUser(
                    method = it.type,
                    idx = it.idx,
                    id = it.loginId,
                    name = it.name,
                    email = it.email,
                    password = it.password,
                    authorities = it.roles.map { role -> SimpleGrantedAuthority(role) }.toMutableList(),
                    attributes = null
                )
            }
    
            if(loginUser != null) {
                return loginUser
            }
    
            val createdUser = userDomainService.createOAuthUser(
                name = userInfo["name"] as String,
                email = userInfo["email"] as String,
                phone = userInfo["mobile"] as String,
                method = LoginMethod.fromCode(
                    userRequest?.clientRegistration?.registrationId ?: throw IllegalArgumentException("Invalid Login registrationId")
                ) ?: throw IllegalArgumentException("Invalid Login Method")
            )
    
            userDomainService.createOAuthToken(
                userIdx = createdUser.id!!,
                accessToken = accessToken,
                tokenType = tokenType,
                expiresIn = expiresIn,
                error = resultCode,
                errorDescription = message)
    
            return LoginUser(
                method = createdUser.method.code,
                idx = createdUser.id!!,
                id = createdUser.loginId,
                name = createdUser.name,
                email = createdUser.email,
                password = null,
                authorities = mutableListOf(SimpleGrantedAuthority("USER")),
                attributes = null
            )
        }
    
    }
    ```
    
    - `OAuth2UserRequest` : ÏÜåÏÖúÎ°úÍ∑∏Ïù∏Ïù¥ ÏÑ±Í≥µÌïòÎ©¥ Î∞úÍ∏âÎêòÎäî `Token` Ï†ïÎ≥¥Î•º ÌôïÏù∏
        - `refresh_token` ÏùÄ ÌôïÏù∏Ïù¥ Î∂àÍ∞ÄÎä• Ìï®
            - ÏûêÎ£åÎ•º Ï∞æÏïÑÎ≥¥Î©¥ Ïó¨Îü¨ Î∞©Î≤ïÏù¥ ÏûàÏßÄÎßå Í∑∏ Ï§ë ÌïòÎÇòÏùò Î∞©Î≤ï ÏÜåÍ∞ú
            - ÏÜåÏä§ ÏΩîÎìú
                - `OAuth2AccessTokenResponseClient` ÌÅ¥ÎûòÏä§ ÌôïÏû•
                    
                    ```kotlin
                    
                    package com.ywpark.exam.api.shared.security.oauth2
                    
                    import org.springframework.core.ParameterizedTypeReference
                    import org.springframework.http.*
                    import org.springframework.security.oauth2.client.endpoint.OAuth2AccessTokenResponseClient
                    import org.springframework.security.oauth2.client.endpoint.OAuth2AuthorizationCodeGrantRequest
                    import org.springframework.security.oauth2.core.OAuth2AccessToken
                    import org.springframework.security.oauth2.core.endpoint.OAuth2AccessTokenResponse
                    import org.springframework.stereotype.Component
                    import org.springframework.util.LinkedMultiValueMap
                    import org.springframework.web.client.RestTemplate
                    
                    @Component
                    class CustomOAuth2AccessTokenResponseClient(
                        private val resetTemplate: RestTemplate
                    ) : OAuth2AccessTokenResponseClient<OAuth2AuthorizationCodeGrantRequest> {
                    
                        override fun getTokenResponse(authorizationGrantRequest: OAuth2AuthorizationCodeGrantRequest?): OAuth2AccessTokenResponse {
                    
                            val tokenUri = authorizationGrantRequest?.clientRegistration?.providerDetails?.tokenUri ?: ""
                            val headers = HttpHeaders().apply {
                                contentType = MediaType.APPLICATION_FORM_URLENCODED
                            }
                    
                            val body = LinkedMultiValueMap<String, String>().apply {
                                add("grant_type", "authorization_code")
                                add("code", authorizationGrantRequest?.authorizationExchange?.authorizationResponse?.code)
                                add("redirect_uri", authorizationGrantRequest?.authorizationExchange?.authorizationRequest?.redirectUri)
                                add("client_id", authorizationGrantRequest?.clientRegistration?.clientId)
                                add("client_secret", authorizationGrantRequest?.clientRegistration?.clientSecret)
                            }
                    
                            val entity = HttpEntity(body, headers)
                            val response: ResponseEntity<Map<String, Any>> = resetTemplate.exchange(
                                tokenUri, HttpMethod.POST, entity, object : ParameterizedTypeReference<Map<String, Any>>() {}
                            )
                    
                            val tokenResponse = response.body ?: throw RuntimeException("OAuth Token API Error")
                            return OAuth2AccessTokenResponse
                                .withToken(tokenResponse["access_token"] as String)
                                .tokenType(OAuth2AccessToken.TokenType.BEARER)
                                .expiresIn((tokenResponse["expires_in"] as String).toLong())
                                .additionalParameters(mapOf("refresh_token" to tokenResponse["refresh_token"] as String))
                                .build()
                        }
                    }
                    ```
                    
                    > `OAuth2AccessTokenResponse.refreshToken()` Ï†ïÏùò Ìï† Ïàò ÏûàÏßÄÎßå ÏµúÏ¢ÖÏ†ÅÏúºÎ°úÎäî `loadUser()` ÏóêÏÑúÎäî ÏâΩÍ≤å Ï†ëÍ∑ºÏù¥ ÏïàÎêòÏÑú `additionalParameters()` Ïóê Î≥ÑÎèÑÎ°ú Îç∞Ïù¥ÌÑ∞Î•º ÏÉùÏÑ±ÌïòÏó¨ Ï†ÑÎã¨ÌïúÎã§.
                    
                    Í∑∏Î†áÍ≤å ÌïòÎ©¥ `userRequest.additionalParameters["refresh_token"]` Ïù¥Îü∞ÏãùÏúºÎ°ú token Í∞íÏùÑ ÌôúÏö© Í∞ÄÎä•
                    > 
                - SecurityConfig.kt
                    
                    ```kotlin
                    .oauth2Login {
                        it
                            .tokenEndpoint {te ->
                                te.accessTokenResponseClient(customOAuth2AccessTokenResponseClient)
                    
                            }
                    }
                    ```
                    
                    > Í∏∞Ï°¥ ÏÑ§Ï†ïÏóê ÏúÑÏùò Ìï≠Î™©Îßå Ï∂îÍ∞ÄÌïòÎ©¥ Îê®
                    > 
    - `super.loadUser(userRequest)` : Î∞úÍ∏âÎ∞õÏùÄ Token Ï†ïÎ≥¥Î•º ÌôúÏö©ÌïòÏó¨ ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥Î•º Ï°∞Ìöå
    - Spring Security
- LoginUser.kt
    
    ```kotlin
    package com.ywpark.exam.api.shared.security
    
    import org.springframework.security.core.GrantedAuthority
    import org.springframework.security.core.userdetails.UserDetails
    import org.springframework.security.oauth2.core.user.OAuth2User
    
    class LoginUser(
        private val method: String,
        private val idx: Long,
        private val id: String,
        private val name: String,
        private val email: String,
        private val password: String?,
        private val authorities: MutableCollection<GrantedAuthority>,
        private val attributes: MutableMap<String, Any>?
    ) : UserDetails, OAuth2User {
    
        // ÏùºÎ∞òÎ°úÍ∑∏Ïù∏ UserDetails
        override fun getAuthorities(): MutableCollection<out GrantedAuthority> = authorities
        override fun getPassword(): String? = password
        override fun getUsername(): String = id
    
        // OAuth2Î°úÍ∑∏Ïù∏ OAuth2User
        override fun getName(): String = id
        override fun getAttributes(): MutableMap<String, Any>? = attributes
    
    }
    ```
    
    - `FormLogin` ÏùÑ ÏÇ¨Ïö©ÌïòÎäî ÏÇ¨Ïö©ÏûêÏôÄ `OAuth2` Î•º ÏÇ¨Ïö©ÌïòÎäî ÏÇ¨Ïö©ÏûêÎ•º Îã§ Ìè¨Ìï®Ìï† Ïàò ÏûàÎäî ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ Í∞ùÏ≤¥
    
- Controller.kt
    
    ```kotlin
    package com.ywpark.exam.api.query.controller
    
    import com.ywpark.exam.api.query.model.response.SearchBoardResponse
    import com.ywpark.exam.api.query.service.BoardQueryService
    import com.ywpark.exam.api.shared.security.LoginUser
    import org.springframework.http.ResponseEntity
    import org.springframework.security.core.annotation.AuthenticationPrincipal
    import org.springframework.web.bind.annotation.GetMapping
    import org.springframework.web.bind.annotation.RequestMapping
    import org.springframework.web.bind.annotation.RestController
    
    @RestController
    @RequestMapping("/api/")
    class BoardQueryController(
        private val boardQueryService: BoardQueryService
    ) {
    
        @GetMapping("boards")
        fun list(@AuthenticationPrincipal user: LoginUser): ResponseEntity<List<SearchBoardResponse>> {
            return ResponseEntity.ok(boardQueryService.list())
        }
    
    }
    ```
    
    - `@AuthenticationPrincipal` Î•º ÌôúÏö©Ìï¥ÏÑú Î°úÍ∑∏Ïù∏ Ìïú ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥Î•º Í∞ÄÏ†∏Ïò¨ Ïàò ÏûàÏùå

## 2-1. Ïò§Î•ò ÏÉÅÌô©

---

- DefaultOAuth2UserService ÌÅ¥ÎûòÏä§Î•º ÏÉÅÏÜçÎ∞õÏïÑÏÑú loadUser() Ìï®ÏàòÏóêÏÑú Î°úÍ∑∏Ïù∏ ÏÑ±Í≥µ Ïãú ÏùëÎãµÏùÑ Î∞õÏïÑÏïº ÌïòÎäîÎç∞ ÏùëÎãµÏùÑ Î™ª Î∞õÎäî ÏÉÅÌô© Î∞úÏÉù
    - Security Î•º ÌôúÏö©ÌïòÎäî Í≤ΩÏö∞ÏóêÎäî ÏùºÎ∞ò FormLogin Ï≤òÎüº 2Í∞ÄÏßÄÏùò URL Ïù¥ Ïù¥ÎØ∏ Ï†ïÏùòÍ∞Ä ÎêòÏñ¥ ÏûàÏùå
        - `{baseUrl}/oauth2/authorization/{registrationId}`  : OAuth Î°úÍ∑∏Ïù∏ Ìò∏Ï∂ú ÌéòÏù¥ÏßÄ
        - `{baseUrl}/login/oauth2/code/{registrationId}`  : OAuth Î°úÍ∑∏Ïù∏ ÏÑ±Í≥µ ÌõÑ ÏΩúÎ∞± URI
    - [https://docs.spring.io/spring-security/reference/servlet/oauth2/login/core.html#oauth2login-sample-redirect-uri](https://docs.spring.io/spring-security/reference/servlet/oauth2/login/core.html#oauth2login-sample-redirect-uri)
    - ÏΩúÎ∞± URI Î•º ÏûÑÏùòÏùò URI Î°ú ÏßÄÏ†ïÌïòÏó¨ ÏùëÎãµ ÌôïÏù∏Ïù¥ Î∂àÍ∞ÄÎä•

# Ïó∞Í¥Ä Í∏∞Ïà†

---

- OpenID Connect (OIDC)
    - OAuth 2.0Ïùò ÌôïÏû•
    - OAuth2 Ïùò Ï£ºÏöî Î™©Ï†ÅÏùÄ Ïù∏Í∞Ä Ïù¥Î©∞, Ïù∏Ï¶ù Ï†àÏ∞®Î•º Ïù∏Í∞ÄÎ•º Î∞õÍ∏∞ ÏúÑÌïú Ï†àÏ∞®
    - OpenID Ïùò Ï£ºÏöî Î™©Ï†ÅÏùÄ Ïù∏Ï¶ù

# Í≥†ÎØºÏÇ¨Ìï≠

---

### 1. Spring Security Ïùò Ï†ÅÏö© Ïó¨Î∂Ä

---

- Security Î•º ÌôúÏö©ÌïòÎ©¥ Ï¢Ä Îçî ÏâΩÍ≥† Îπ†Î•¥Í≤å Ï†ÅÏö©Ìï† Ïàò ÏûàÏßÄÎßå Spring Security Ïóê ÎåÄÌïú ÌïôÏäµÏù¥ Ïñ¥Îäê
Ï†ïÎèÑ ÌïÑÏöî.
- Security Í∞Ä Ï†ÅÏö©ÎêòÏßÄ ÏïäÏùÄ ÏÉÅÌÉúÏóêÏÑú Ïù¥ÎØ∏ Ïö¥ÏòÅÏ§ëÏù∏ ÏÑúÎπÑÏä§ÎùºÎ©¥ Ïò§ÌûàÎ†§ Ï†ÅÏö©ÌïòÍ∏∞Í∞Ä ÏâΩÏßÄ ÏïäÏùÑ Í≤ÉÏúºÎ°ú Î≥¥Ïù¥Î©∞, ÌîÑÎ°úÏ†ùÌä∏ Ï¥àÍ∏∞ Íµ¨ÏÑ± Îã®Í≥ÑÌïòÎ©¥ Í≥†Î†§Ìï¥ Î≥º ÎßåÌïú Í∞ÄÏπòÎäî ÏûàÏùå.

### 2. ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ Í¥ÄÎ¶¨Î•º Session VS Token Î∞©Ïãù

---

- OAuth ÏóêÏÑú Token Ïù¥ Î∞úÍ∏âÎêòÎäîÎç∞ ÏÑúÎπÑÏä§ Ïö¥ÏòÅÏóê ÌÜµÏùºÏÑ±ÏùÑ Ï£ºÎ†§Î©¥ Token Î∞©Ïãù Ï†ÅÏö©Ïù¥ Ï†úÏùº Ï¢ãÎã§Í≥† ÏÉùÍ∞ÅÌï®
- Session Í¥ÄÎ¶¨ÏôÄ Token Í¥ÄÎ¶¨ÏóêÎäî Í∞Å Í∞ÅÏùò Ïû•Îã®Ï†êÏù¥ ÏûàÍ∏∞ ÎïåÎ¨∏Ïóê ÏÑúÎπÑÏä§ÏóêÏÑú Ï∂îÍµ¨ÌïòÎäî Î∞©Ìñ•Ïóê ÎßûÍ≤å
Ï†ÅÏö©ÌïòÎ©¥ Îê† Í≤ÉÏúºÎ°ú ÌåêÎã®Îê®

### 3. Session Í¥ÄÎ¶¨Î•º Ïñ¥ÎñªÍ≤å Ìï† Í≤ÉÏù∏Í∞Ä

---

- Í∏∞Ï°¥ ÏÑúÎπÑÏä§ÏóêÏÑú Session ÏùÑ ÌôúÏö©ÌïòÍ≥† ÏûàÎã§Î©¥ OAuth Î•º ÌôúÏö©ÌïòÎçîÎùºÎèÑ Í∑∏ÎåÄÎ°ú Ïú†ÏßÄ

### 4. ÏûêÎèôÎ°úÍ∑∏Ïù∏ Ï≤òÎ¶¨ Î∞©Î≤ï

---

- Spring Security Î•º ÌôúÏö©ÌïúÎã§Î©¥ `rememberMe` Í∏∞Îä•ÏùÑ ÌôúÏö©Ìï† Ïàò ÏûàÏùå
- Spring Security ÌôúÏö©ÌïòÏßÄ ÏïäÎäîÎã§Î©¥ `rememberMe` ÏôÄ ÎπÑÏä∑ÌïòÍ≤å `Token` ÏùÑ Î∞úÌñâÌïòÏó¨ ÏûêÎèôÎ°úÍ∑∏Ïù∏ÏùÑ Í∏∞Îä•ÏùÑ Ï†ÅÏö©
    - Î°úÍ∑∏Ïù∏ ÏÑ±Í≥µ ÏãúÏóê `Token` ÏùÑ Î∞úÌñâÌïòÏó¨ Client Ïóê `Cookie` Î°ú Ï†ÑÎã¨
    - `Cookie` Î°ú Ï†ÑÎã¨ÌïòÍ∏∞Ïóê Í∏∞Î≥∏Ï†ÅÏúºÎ°ú ÎßåÎ£åÏùºÏûêÎ•º Ï†ïÏùò
        - ÎßåÎ£å Ïù¥ÌõÑÏùò Ï†àÏ∞®Îäî Ï†ïÏ±ÖÏóê Îî∞Îùº Ï†ïÏùòÌïòÏó¨ Ï†ÅÏö©
        ( Ïû¨ Î°úÍ∑∏Ïù∏ Î∞©Ïãù, ÎßåÎ£åÏùºÏùÑ ÏûêÎèôÏúºÎ°ú Í∞±Ïã† )
    - ÏÇ¨Ïö©Ïûê Ïó¨Îü¨ ÌôòÍ≤ΩÏóêÏÑú Î°úÍ∑∏Ïù∏ Ìï† Ïàò ÏûàÍ∏∞ ÎïåÎ¨∏Ïóê Ïù¥ Î∂ÄÎ∂ÑÎèÑ Í≥†Î†§Ìï¥ÏÑú `Token` Í¥ÄÎ¶¨ Í≥†ÎØº ÌïÑÏöî

### 5. Î°úÍ∑∏ÏïÑÏõÉ Ï≤òÎ¶¨ Î∞©Î≤ï

---

- `Client` ÏóêÏÑú Î°úÍ∑∏ÏïÑÏõÉÏùÑ ÌïúÎã§Í≥† `Authorization / Resource Server`  ÏóêÏÑúÎèÑ Î°úÍ∑∏ÏïÑÏõÉÏù¥
ÎêòÎ©¥ ÏïàÎêòÎäî Í≤ÉÏúºÎ°ú ÌåêÎã®Îê®
- `Session / Cookie`  Ï†ïÎ≥¥Î•º ÏÇ≠Ï†ú ÌïòÎäî Î∞©ÏãùÏúºÎ°ú ÏßÑÌñâ
    - Î≥¥Ïïà ÏÉÅÏúºÎ°ú ÎØºÍ∞êÌïòÎã§Î©¥ Î∞úÍ∏âÎ∞õÏùÄ `Token` Ï†ïÎ≥¥Î•º ÎßåÎ£å/ÌèêÍ∏∞ Ï≤òÎ¶¨

### 6. Î∞úÍ∏âÎ∞õÏùÄ ACCESS_TOKEN ÏùÄ Ïñ¥ÎñªÍ≤å Í¥ÄÎ¶¨ Ìï† Í≤ÉÏù∏Í∞Ä

---

- Í∞úÎ∞ú ÏÇ¨Ìï≠Ïóê Îî∞Îùº Í¥ÄÎ¶¨ Ïó¨Î∂ÄÍ∞Ä Í≤∞Ï†ï Îê† Í≤ÉÏúºÎ°ú ÌåêÎã®Îê®
- API Ìò∏Ï∂úÏù¥ ÎπàÎ≤àÌïòÎã§Î©¥ Î≥ÑÎèÑÎ°ú Ï†ÄÏû•ÌïòÏó¨ TOKEN Í¥ÄÎ¶¨Í∞Ä ÌïÑÏöî
- Í∑∏Î†áÏßÄ ÏïäÎã§Î©¥ Î≥ÑÎèÑÎ°ú Í¥ÄÎ¶¨Ìï† ÌïÑÏöîÎäî ÏóÜÏñ¥ Î≥¥ÏûÑ

### 7. ACCESS_TOKEN Í∞±Ïã†ÏùÄ Ïñ¥ÎñªÍ≤å Ï≤òÎ¶¨ Ìï† Í≤ÉÏù∏Í∞Ä

---

- `Refresh Token` ÏùÄ Cookie ÏóêÏÑú HttpOnly , Secure ÏÜçÏÑ±ÏùÑ Ï§òÏÑú Î≥¥ÏïàÏùÑ Ï¢Ä Îçî Í∞ïÌôîÌïòÍ≥† `Access Token` ÏùÄ Response Body Î°ú Îç∞Ïù¥ÌÑ∞Î•º Ï†ÑÎã¨ÌïòÏó¨ Í¥ÄÎ¶¨.
- `Access Token` ÎßåÎ£å Ï†ÑÏóê Client ÏóêÏÑú Í∞±Ïã† ÏöîÏ≤≠
    - Client ÏóêÏÑú ÎßåÎ£å ÏãúÍ∞ÑÏùÑ Ï≤¥ÌÅ¨ÌïòÏó¨ ÏùºÏ†ï ÏãúÍ∞Ñ Ï†ÑÏóê Í∞±Ïã† ÌïòÎèÑÎ°ù Ï†ïÏùò
- Server ÏóêÏÑú 401 Status Code Î•º ÏùëÎãµÎ∞õÏúºÎ©¥ Access Token ÏùÑ  API Î•º ÌÜµÌïòÏó¨ Ïû¨ Î∞úÍ∏â Î∞õÏùÄ ÌõÑÏóê
Í∏∞Ï°¥ HTTP API Î•º Ïû¨ Ìò∏Ï∂ú
- `Access Token` ÏùÑ Í∞±Ïã†Ìï† Îïå `Refresh Token` ÎèÑ Í∞ôÏù¥ Í∞±Ïã†ÌïòÎäî RTR  ( Refresh Token Rotation ) 
Î∞©ÏãùÎèÑ ÏÉùÍ∞ÅÌï¥ Î≥º Ïàò ÏûàÏùå

# Ï∞∏Í≥† ÏûêÎ£å

---

- [https://developers.naver.com/docs/login/api/api.md](https://developers.naver.com/docs/login/api/api.md)
- [https://m42-orion.tistory.com/161](https://m42-orion.tistory.com/161)
- ChatGPT